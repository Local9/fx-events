using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Moonlight.Generators.Models;
using Moonlight.Generators.Syntax;

namespace Moonlight.Generators
{
    public class SyntaxReceiver : ISyntaxContextReceiver
    {
        private static string Notice => "// Auto-generated by the Serialization Generator.";

        private static readonly Dictionary<string, string> PredefinedTypes = new()
        {
            { "bool", "Bool" },
            { "byte", "Byte" },
            { "byte[]", "Bytes" },
            { "char", "Char" },
            { "char[]", "Chars" },
            { "decimal", "Decimal" },
            { "double", "Double" },
            { "short", "Int16" },
            { "int", "Int32" },
            { "long", "Int64" },
            { "float", "Single" },
            { "string", "String" },
            { "sbyte", "SByte" },
            { "ushort", "UInt16" },
            { "uint", "UInt32" },
            { "ulong", "UInt64" }
        };

        public readonly List<WorkItem> WorkItems = new();
        public List<string> Logs = new();

        public CodeWriter Compile(WorkItem item)
        {
            var symbol = item.TypeSymbol;
            var code = new CodeWriter();

            code.AppendLine("using System.IO;");

            foreach (var usingDecl in item.Unit.Usings)
            {
                code.AppendLine($"using {usingDecl.Name};");
            }

            code.AppendLine();

            var properties = new List<IPropertySymbol>();
            var shouldOverride =
                symbol.BaseType != null && symbol.BaseType.GetAttributes()
                    .Any(self => self.AttributeClass is { Name: "SerializationAttribute" });

            var members = new List<ISymbol>();

            members.AddRange(symbol.GetMembers());

            if (symbol.BaseType != null)
                members.AddRange(symbol.BaseType.GetMembers().Where(self => members.All(deep => self.Name != deep.Name)));

            foreach (var type in symbol.Interfaces)
            {
                members.AddRange(type.GetMembers().Where(self => members.All(deep => self.Name != deep.Name)));
            }

            foreach (var member in members)
            {
                if (member is not IPropertySymbol propertySymbol) continue;
                if (propertySymbol.GetAttributes()
                    .Any(self => self.AttributeClass is { Name: "IgnoreAttribute" })) continue;
                if (propertySymbol.DeclaredAccessibility != Accessibility.Public || propertySymbol.IsIndexer ||
                    propertySymbol.IsReadOnly || propertySymbol.IsWriteOnly) continue;

                properties.Add(propertySymbol);
            }

            using (code.BeginScope($"namespace {item.NamespaceDeclaration.Name}"))
            {
                using (code.BeginScope(
                    $"public partial class {item.ClassDeclaration.Identifier}{item.ClassDeclaration.TypeParameterList} {item.ClassDeclaration.ConstraintClauses}"))
                {
                    if (!item.ClassDeclaration.DescendantNodes().Any(self =>
                        self is ConstructorDeclarationSyntax constructorDecl &&
                        constructorDecl.ParameterList.Parameters.Count == 0))
                    {
                        using (code.BeginScope($"public {symbol.Name}()"))
                        {
                        }
                    }

                    using (code.BeginScope($"public {symbol.Name}(BinaryReader reader)"))
                    {
                        code.AppendLine("UnpackSerializedBytes(reader);");
                    }

                    if (!HasImplementation(symbol, "PackSerializedBytes"))
                    {
                        using (code.BeginScope(
                            $"public {(shouldOverride ? "new " : string.Empty)}void PackSerializedBytes(BinaryWriter writer)"))
                        {
                            code.AppendLine(Notice);

                            foreach (var property in properties)
                            {
                                AppendWriteLogic(code, property.Name, property.Type);
                            }
                        }
                    }

                    if (!HasImplementation(symbol, "UnpackSerializedBytes"))
                    {
                        using (code.BeginScope(
                            $"public {(shouldOverride ? "new " : string.Empty)}void UnpackSerializedBytes(BinaryReader reader)"))
                        {
                            code.AppendLine(Notice);

                            foreach (var property in properties)
                            {
                                AppendReadLogic(code, property.Name, property.Type);
                            }
                        }
                    }
                }
            }

            return code;
        }

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is not ClassDeclarationSyntax classDecl) return;

            var symbol = (INamedTypeSymbol) context.SemanticModel.GetDeclaredSymbol(context.Node);
            var attribute = symbol?.GetAttributes()
                .FirstOrDefault(self => self.AttributeClass is { Name: "SerializationAttribute" });

            if (attribute == null) return;

            CompilationUnitSyntax unit = null;
            NamespaceDeclarationSyntax namespaceDecl = null;
            SyntaxNode parent = classDecl;

            while ((parent = parent.Parent) != null)
            {
                switch (parent)
                {
                    case CompilationUnitSyntax syntax:
                        unit = syntax;

                        break;
                    case NamespaceDeclarationSyntax syntax:
                        namespaceDecl = syntax;

                        break;
                }
            }

            if (unit == null || namespaceDecl == null) return;

            WorkItems.Add(new WorkItem
            {
                TypeSymbol = symbol, SemanticModel = context.SemanticModel, ClassDeclaration = classDecl, Unit = unit,
                NamespaceDeclaration = namespaceDecl
            });
        }

        private static bool HasImplementation(INamespaceOrTypeSymbol symbol, string methodName)
        {
            foreach (var member in symbol.GetMembers())
            {
                if (member is IMethodSymbol methodSymbol && methodSymbol.Name == methodName)
                {
                    return true;
                }
            }

            return false;
        }

        private void AppendWriteLogic(CodeWriter code, string name, ITypeSymbol type)
        {
            var nullable = type.NullableAnnotation == NullableAnnotation.Annotated;

            if (nullable)
            {
                type = ((INamedTypeSymbol) type).TypeArguments.First();

                code.AppendLine($"writer.Write({name}.HasValue);");
                code.AppendLine($"if ({name}.HasValue)");
                code.Append("\t");
            }

            var identifier = nullable ? $"{name}.Value" : name;

            if (IsPrimitive(type))
            {
                code.AppendLine($"writer.Write({identifier});");
            }
            else
            {
                switch (type.TypeKind)
                {
                    case TypeKind.Enum:
                        code.AppendLine($"writer.Write((int) {identifier});");

                        break;
                    case TypeKind.Struct:
                    case TypeKind.Class:
                        code.AppendLine($"{name}.PackSerializedBytes(writer);");

                        break;
                    case TypeKind.Array:
                        var array = (IArrayTypeSymbol) type;

                        using (code.BeginScope())
                        {
                            code.AppendLine($"writer.Write({name}.Length);");

                            using (code.BeginScope($"for (var idx = 0; idx < {name}.Length; idx++)"))
                            {
                                AppendWriteLogic(code, $"{name}[idx]", array.ElementType);
                            }
                        }

                        break;
                }
            }
        }

        private void AppendReadLogic(CodeWriter code, string name, ITypeSymbol type)
        {
            var nullable = type.NullableAnnotation == NullableAnnotation.Annotated;

            if (nullable)
            {
                type = ((INamedTypeSymbol) type).TypeArguments.First();
                code.AppendLine("if (reader.ReadBoolean())");
                code.Append("\t");
            }

            if (IsPrimitive(type))
            {
                code.AppendLine(
                    $"{name} = reader.Read{(PredefinedTypes.TryGetValue(type.Name, out var result) ? result : type.Name)}();");
            }
            else
            {
                switch (type.TypeKind)
                {
                    case TypeKind.Enum:
                        code.AppendLine($"{name} = ({type.Name}) reader.ReadInt32();");

                        break;
                    case TypeKind.Struct:
                    case TypeKind.Class:
                        code.AppendLine($"{name} = new {type.Name}(reader);");

                        break;
                    case TypeKind.Array:
                        var array = (IArrayTypeSymbol) type;

                        using (code.BeginScope())
                        {
                            code.AppendLine("var length = reader.ReadInt32();");
                            code.AppendLine($"{name} = new {array.ElementType}[length];");

                            using (code.BeginScope("for (var idx = 0; idx < length; idx++)"))
                            {
                                AppendReadLogic(code, $"{name}[idx]", array.ElementType);
                            }
                        }

                        break;
                }
            }
        }

        private static bool IsPrimitive(ITypeSymbol type)
        {
            switch (type.SpecialType)
            {
                case SpecialType.System_Boolean:
                case SpecialType.System_SByte:
                case SpecialType.System_Int16:
                case SpecialType.System_Int32:
                case SpecialType.System_Int64:
                case SpecialType.System_Byte:
                case SpecialType.System_UInt16:
                case SpecialType.System_UInt32:
                case SpecialType.System_UInt64:
                case SpecialType.System_Single:
                case SpecialType.System_Double:
                case SpecialType.System_Char:
                case SpecialType.System_String:
                case SpecialType.System_Object:
                    return true;
                default:
                    return false;
            }
        }
    }
}